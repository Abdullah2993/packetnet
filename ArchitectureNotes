Packet.Net

The high level design goals of Packet.Net are:
- High performance. As little memory allocation/access and cpu usage as possible
- Simple, modular design
- Clear and well documented api


Packet.Net is a rewrite of SharpPcap's packet parsers.

SharpPcap's packet parsers have a few shortcomings in their design. To understand
what these are it is important to know more about SharpPcap's design.


SharpPcap's packet parsing
--------------------------
SharpPcap considers all packets to be of type 'Packet'. Packet types are subclassed, so
a UdpPacket is an IpPacket which is an EthernetPacket which is a Packet. This is useful
because a user can have a 'UdpPacket udp' and can access the source mac address via
'udp.SourceHwAddress', without having to jump through any hoops.

As packets are received they are classified into their most specific type, first by
looking at whether they are an EthernetPacket, checking if the EthernetPacket is an IpPacket
and then if the IpPacket is a Udp or Tcp packet. At this time the most specific packet is created
by passing in the byte stream, like TcpPacket tcp = new TcpPacket(packetBytes);

SharpPcap performs lazy field parsing. Each packet field is extracted from the byte stream
when requested. Some caching is performed in the TcpPacket class but in most cases the
values are re-parsed by reading a number of bytes from a specific offset each time
the class property is read.


Shortcomings of SharpPcap's design
----------------------------------

Creating packets from values is cumbersome. Because a TcpPacket is an IpPacket which is an
EthernetPacket, to create a TcpPacket requires somehow knowing how many bytes to allocate for
an Ethernet header + Ip header (ipv4 or ipv6 needs to be known) + TcpHeader + TcpPayload.
The current packet constructor methods require that to construct a TcpPacket from values
that an IpPacket, a tcp packet payload, and source and destination ports be passed in. This
may confuse users because to create an IpPacket from values one must also pass in an ip packet
payload, which is actually ignored by the TcpPacket constructor since its own header bytes
plus payload replace the original ip payload.


Shortcomings in SharpPcap's implementation
------------------------------------------

SharpPcap allows direct access to the header and content bytes of a packet. The Packet class,
defined in Packet.cs, defines public accessors for retrieving the byte[] of the header and
packet bytes, byte[] Bytes and byte[] Header. These routines do not take care to make the
packets valid, ie. if the size of a TcpPacket changes, retrieving the IpPacket bytes does not
update the IpPacket lengths for the corresponding changes to the TcpPacket size.


Design improvements over SharpPcap
----------------------------------

The inheritance order should be reversed. A user refers to the payload of an EthernetPacket
to get an IpPacket, and the IpPacket payload to get the TcpPacket. Reversing the encapsulation
better matches how packets are parsed. It also allows for modifying the type of packet without
conflicting with the original class type, such as if a TcpPacket has its IpPacket payload
modified to contain a UdpPacket with SharpPcap we have an impossible situation because
we can't convert a TcpPacket instance to a UdpPacket instance.

Eliminating the inheritance model of SharpPcap makes packets easier to construct by value.
In SharpPcap a TcpPacket required building an EthernetPacket and an IpPacket and passing
both to a TcpPacket constructor that would discard their payloads and copy their headers
into a byte[] that was allocated to fit the headers plus the tcp payload. In Packet.Net because
each packet is separate a user is less confused by having to build both an IpPacket, that
contains an EthernetPacket, and an EthernetPacket separately.


Implementation improvements over SharpPcap
------------------------------------------

Packet.Net's Packet has a 'byte[] Bytes' get accessor retrieves packet bytes from
the current packet as well as all sub packets.

System.Array is used to retrieve bytes from packets, instead of using helper classes.
The helper classes in SharpPcap don't provide meaningful improvements over the standard
System.Array methods.


Things kept the same as SharpPcap
---------------------------------

Packet.Net does as much lazy field evaluation as possible. Values are read from memory only when
the user calls the appropriate get accessor. This greatly simplifies the number of memory
reads in most cases and is a close match in the cases where the user wants to read all fields.
